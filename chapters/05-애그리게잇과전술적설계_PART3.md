# 05. 애그리게잇과 전술적 설계_PART3

## 애그리게잇 모델링

도메인 모델에서 애그리게잇을 구현할 때, 종종 몇 가지 함정에 빠질 수 있다.
그 중 가장 대표적인 예는 바로 **빈약한 도메인 모델(Poor Domain Model)**이다.

이는 객체지향 도메인 모델을 사용하면서도 모든 애그리게잇이 비즈니스 행위 없이 단순한 읽기/쓰기 접근자만을 갖는 형태를 의미한다.
이러한 현상은 도메인을 모델링하면서 비즈니스보다는 기술적인 측면에만 초점을 맞출 때 발생하는 경향이 있다.

비즈니스 로직이 도메인 모델 외부, 예를 들어 애플리케이션 서비스로 새어 나가지 않도록 주의가 필요하다.
하지만 이러한 문제는 겉으로 드러나지 않아 쉽게 발견되지 않기 때문에 더 위험하다.

비즈니스 로직을 도우미 클래스나 유틸리티 클래스에 위임하는 방식은 바람직하지 않다.
이런 접근은 객체의 정체성을 흐리게 만들고, 요구사항을 올바르게 반영하지 못한다.
결과적으로 도메인 모델이 약화되며, 그로 인한 오류가 개발자에게 부담으로 돌아올 수 있다.

------

### ※ 함수형 프로그래밍의 경우

함수형 프로그래밍을 사용하는 경우에는 이와 관련된 규칙이 많이 달라진다.
객체지향에서는 빈약한 도메인 모델이 문제가 되지만, 함수형에서는 **데이터와 행위의 분리**가 오히려 권장된다.

불변 데이터 구조나 레코드 타입으로 데이터를 모델링하고, 이를 제어하는 순수 함수로 로직을 구현하는 방식이 일반적이다.
따라서 함수형 언어로 DDD를 적용하려면 일부 원칙을 재정의하거나, 아예 해당되지 않는 경우도 있음을 인지해야 한다.

------

### 애그리게잇 설계 시 기본 구성 요소

- **애그리게잇 루트 엔터티 생성**
  애그리게잇 루트는 시스템 전체에서 고유한 식별성을 가져야 한다.

- **본질적인 속성 정의**
  필요한 속성에 대해 읽기 접근자를 정의할 수 있다.
  쓰기 접근자는 외부에 공개하지 않고, 객체 내부의 행위를 통해 상태 변경이 이루어지도록 해야 한다.
  객체지향 언어는 내부 상태 변경 메서드를 사용하고, 함수형 언어는 새로운 값을 반환하는 방식으로 설계한다.

  속성 변경을 단순한 setter로 외부에 노출시키면, 값 변경 로직이 모델 밖으로 분리되어 빈약한 도메인 모델로 전락할 수 있다.

- **복잡한 행위 추가**
  도메인 주도 설계(DDD)의 핵심은 바운디드 컨텍스트 내에서 보편 언어(Ubiquitous Language)를 기반으로 모델링하는 것이다.
  단순히 구현 중심으로 접근하기보다는 도메인 전문가와의 긴밀한 협업을 통해 의미 있는 모델을 함께 만들어야 한다.

------

## 추상화는 조심스럽게 선택

효과적인 소프트웨어 모델은 비즈니스의 실제 방식과 흐름에 맞춘 **적절한 수준의 추상화**에 기반을 둔다.
각 개념마다 지나치지도, 부족하지도 않은 추상화 수준을 유지하는 것이 중요하다.

보편 언어와 도메인 전문가의 인사이트를 기반으로 추상화를 설정하면, 훨씬 정밀하고 유효한 모델링이 가능하다.
하지만 다음과 같은 실수는 주의해야 한다:

- 소프트웨어 모델의 언어가 도메인 전문가의 멘탈 모델과 맞지 않음
- 추상화 수준이 너무 높아져 개별적 세부사항을 표현하기 어려워짐
- 클래스마다 특수한 예외를 처리하느라 복잡한 계층 구조가 생김
- 중요하지 않은 문제에 몰두한 나머지 불필요하게 많은 코드가 생성됨
- 사용자 인터페이스(UI)에까지 부정적인 영향이 미침
- 결과적으로 시간, 비용, 리소스가 낭비됨

소프트웨어 프로젝트 초기에 미래의 모든 요구사항을 예측해 반영하는 것은 불가능하다.
앞으로도 새로운 스크럼 개념이나 도메인 요구는 계속 추가될 것이고, 현재 모델은 이를 미리 알 수 없다.

지금 당장 비즈니스가 필요로 하는 것을 충실히 모델링해야 한다.
이런 방식이야말로 시간과 예산을 아끼고, 복잡성을 줄이며, 유용한 바운디드 컨텍스트에 기반한 더 나은 서비스를 설계할 수 있는 길이다.


## 올바른 크기의 애그리게잇

애그리게잇의 경계를 설정할 때는, **비즈니스 불변사항을 보호할 수 있는 일관성 경계를 유지**하면서, **너무 큰 클러스터를 만들지 않도록** 주의해야 한다.
 이미 큰 애그리게잇을 만들어 놓았다면, 이 과정을 통해 더 작은 단위로 리팩토링하는 데도 활용할 수 있다.

다음은 올바른 경계를 설계하는 데 도움이 되는 단계별 접근법이다.

1. **작은 애그리게잇 설계에 집중하기**
    애그리게잇 설계의 두 번째 규칙에 따라, **작은 단위로 구성**하는 것을 우선시한다.
    각 엔터티는 단일 루트 엔터티와 밀접하게 연관된 필드(속성/프로퍼티)를 중심으로 구성되어야 한다.
    이때 단순히 식별과 조회에 필요한 속성뿐 아니라, 애그리게잇이 초기 상태에서 **유효하게 생성되기 위해 필요한 모든 속성**도 포함되어야 한다.
2. **비즈니스 불변사항 보호 고려하기**
    애그리게잇 설계의 첫 번째 규칙인 **“애그리게잇 경계 내의 불변사항을 보호하라”**는 원칙을 적용한다.
    애그리게잇 A1을 설계할 때, 이미 정의된 다른 애그리게잇들과의 관계를 고려해 **A1이 변경될 때 어떤 것들이 함께 갱신되어야 하는지** 도메인 전문가와 확인한다.
    이 과정을 통해 연관된 애그리게잇의 목록과 각 일관성 규칙을 파악한다.
3. **갱신 타이밍 파악하기**
    연관된 애그리게잇들 간의 갱신에 어느 정도 시간이 걸려도 괜찮은지, **도메인 전문가에게 직접 확인**한다.
    현실적인 임계값을 찾기 어려울 경우, **의도적으로 과장된 시간이 허용 가능한지** 먼저 질문해보는 것도 하나의 방법이다.
4. **즉시 반응이 필요한 경우 경계 재검토하기**
    두 엔터티 간에 갱신이 즉시 일어나야 하는 경우, **동일한 애그리게잇 안에서 관리**하는 방안을 검토한다.
    반면, 즉각적인 처리가 아닌 경우라면 애그리게잇 설계의 네 번째 규칙인 **“결과적 일관성을 통해 갱신하라”**는 방식을 사용할 수 있다.

비즈니스 측에서 모든 애그리게잇이 동시에 갱신돼야 한다고 주장할 수 있지만, **그 주장이 실제 비즈니스 요구인지**는 반드시 검토해야 한다.
 모든 트랜잭션에서 즉각적인 일관성을 요구하는 경우는 **현실적으로 매우 드물다**.

결국, 어떤 갱신이 즉시 일어나야 하고 어떤 것은 일정 시간 안에 반영되어도 되는지는 **비즈니스가 판단할 몫**이다.
 즉, **즉각적 트랜잭션 처리가 필요한 것들만이 같은 애그리게잇 안에서 관리되어야 한다**는 의미다.

비즈니스의 실제 동작 방식을 깊이 있게 이해하고 이를 모델링할수록, 도메인 오퍼레이션은 소프트웨어에 통찰력을 제공하며, **비즈니스 가치를 극대화하는 방향으로 작용**하게 된다.


## 테스트 가능한 단위

애그리게잇은 **단위 테스트가 가능한 구조**로 설계되어야 한다.

애그리게잇의 모든 오퍼레이션이 **예상대로 동작하는지, 비즈니스 로직을 올바르게 수행하는지** 테스트할 수 있어야 하며,
 이런 구조는 결과적으로 **정확성, 품질, 안정성**을 보장하는 기반이 된다.