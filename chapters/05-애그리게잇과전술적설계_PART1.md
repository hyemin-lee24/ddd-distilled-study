# 05. 애그리게잇과 전술적 설계

## 왜 필요할까?

### 예시: 두 개의 바운디드 컨텍스트

- **바운디드 컨텍스트 1**
  - `Product`
  - `BacklogItem`
  - `Release`
  - `Sprint`
  - `Discussion` (값 객체로 모델링됨)
- **바운디드 컨텍스트 2**
  - `Forum`
  - `Calendar`
  - `Discussion`
  - `CalendarEntry`
  - `Post`

→ 각 바운디드 컨텍스트에 정의된 개념들은 **애그리게잇**이며,
 명시되지 않은 개념인 `Discussion`은 **값 객체**로 모델링된 예시임.

해당 장에서는 `Product`, `BacklogItem`, `Release`, `Sprint`와 같은 애그리게잇을 어떻게 모델링할지를 상세히 다룸.

------

## 엔터티

- 독립적인 개념.
- 같은 형태를 띠거나 다른 형태의 엔터티들과 특성이 구별될 수 있도록 고유한 **식별성**을 가짐.
- 유일성과 독립성이 핵심.

------

## 애그리게잇

- **1개 이상의 엔터티**로 구성됨.
- 그중 하나는 반드시 **애그리게잇 루트**로 지정됨.
- **값 객체**를 구성 요소로 포함할 수 있음.
- 애그리게잇 루트는 해당 애그리게잇의 **개념적 명칭**이 됨.
- 루트 엔터티는 내부 요소들에 대해 **소유권**을 갖고 있음.

------

## 값 객체

- 값을 **불변**의 개념적 완전성으로 모델링.
- **식별성 없음**.
- 값 형태로 캡슐화된 속성 자체로 동일성 비교.
- **엔터티를 서술하거나 수량화, 측정**하는 데 사용됨.

------

## 트랜잭션 경계

- 각 애그리게잇은 일관성 있는 **트랜잭션 경계**를 형성함.
- 하나의 트랜잭션 안에서 해당 애그리게잇의 모든 구성 요소는 **비즈니스 규칙**을 준수하며 일관성 있게 처리되어야 함.
- 단, 애그리게잇 내부에 **트랜잭션 이후 일관성이 필요 없는 구성 요소**가 있을 수 있음. 이를 포함하는 것이 잘못된 것은 아님.

------

### 넓은 의미의 트랜잭션

- 애그리게잇에 대한 변경을 **독립적**으로 다루고,
- 애그리게잇의 상태나 이벤트 소싱을 **항상 정확하고 안전하게 트랜잭션으로 처리**해야 함.
- 비즈니스 오퍼레이션마다 **비즈니스 불변성**을 지키도록 설계하는 것이 핵심.

------

## 정리

- **트랜잭션 경계**를 두는 이유는 **비즈니스 규칙** 때문이다.
- 애그리게잇이 완전하고 유효한 상태로 저장되지 않으면,
   그 트랜잭션은 비즈니스 규칙을 **위반**한 것으로 간주됨.
- 따라서, **트랜잭션의 성공과 일관성**을 보장하도록 애그리게잇을 구성해야 한다.
- 즉, **비즈니스 규칙**이란 무엇이 트랜잭션 단위로서 **완전하고 일관되게 처리**돼야 하는지를 판단하는 기준이 된다.