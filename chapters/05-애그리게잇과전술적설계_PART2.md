# 05. 애그리게잇과 전술적 설계_PART2

## 애그리게잇 경험 법칙

> DDD를 신중하게 적용할 때, 효과적으로 동작하는 애그리게잇을 설계할 수 있도록 돕는 가이드

### 기본 규칙

1. 애그리게잇 경계 내에서 **비즈니스 불변사항 보호**
2. **작은 애그리게잇**을 설계
3. 오직 **ID를 통해** 다른 애그리게잇을 참조
4. **결과적 일관성**을 사용해 다른 애그리게잇 갱신

------

## 규칙 1: 애그리게잇 경계 내의 비즈니스 불변사항 보호

- 트랜잭션이 **커밋될 때** 비즈니스의 일관성이 보장되도록
   애그리게잇의 구성 요소를 결정해야 함.
- **사례**: `BacklogItem` 애그리게잇
  - 모든 `Task` 인스턴스의 `hoursRemaining`이 0일 때
     `BacklogItem`의 `status`는 반드시 `DONE`으로 설정
  - 트랜잭션 이후 반드시 지켜져야 할 **명확한 비즈니스 불변사항**

------

## 규칙 2: 작은 애그리게잇을 설계

- **작은 애그리게잇**은 메모리 사용량이 적고, 빠르게 로드되며,
   **가비지 컬렉션** 성능도 더 좋음
- 작은 애그리게잇은
   **더 자주**, **더 성공적으로** 트랜잭션을 수행함
- **SRP (단일 책임 원칙)**
  - 애그리게잇이 너무 많은 책임을 지고 있다면
     크기와 역할에 대해 재논의 필요

------

## 규칙 3: 오직 식별자로만 다른 애그리게잇을 참조

- 작게 분리된 각 애그리게잇은
   필요한 다른 애그리게잇을 **ID로만** 참조함
- 동일한 트랜잭션 내에서 여러 애그리게잇을 **수정하려는 시도 금지**
- 이 규칙은 다음을 가능하게 함:
  - 더 적은 메모리 사용
  - 빠른 리파지토리 로딩
  - 명확한 트랜잭션 분리 유지
- ID 참조만 사용하면
   다양한 저장 메커니즘(RDB, 문서 DB, 키-값 저장소 등)에서도 유연하게 사용 가능

------

## 규칙 4: 결과적 일관성을 사용해 다른 애그리게잇 갱신

- **사례**: `BacklogItem`은 `Sprint`와 연계되어 수행됨
- `BacklogItem`은 관련된 `Sprint`의 `SprintId`를 포함하고,
   하나의 트랜잭션 안에서 이 상태를 관리함
- `Sprint`는 `BacklogItem`이 할당됐는지 어떻게 확신할까?
   → `BacklogItem` 트랜잭션 내에서
   `BacklogItemCommitted` 도메인 이벤트를 발행
- `BacklogItemCommitted`가 로컬 구독자에게 전달되면,
   `Sprint`는 새로운 트랜잭션을 시작하고
   해당 `BacklogItemId`를 보유한 상태로 업데이트
- `Sprint`는 `CommitedBacklogItem` 엔터티에
   `BacklogItemId`를 보유하게 됨
- 이는 4장에서 다룬 **컨텍스트 매핑 및 전략적 설계**와 연관

> 도메인 이벤트는 애그리게잇에 의해 발행되고,
>  관심 있는 바운디드 컨텍스트로 전달된다.

------

### 결과적 일관성이 두렵게 느껴진다면

- 실제 경험 전에는 우려가 있을 수 있으나,
   걱정할 필요는 없음
- 비즈니스에 의해 정의된 **트랜잭션 경계**에 따라
   모델을 **애그리게잇 단위로 분리**해야 함
- 결과적으로 **트랜잭션 실패** 경험을 줄일 수 있음